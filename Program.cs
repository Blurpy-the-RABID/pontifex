using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace VincentFantini {

    class Program {

        static void Main(string[] args) {
            Deck encryptDeck = new Deck(); // This is the first Deck that's used to encrypt the plaintext message.
            Recorder notePad = new Recorder(); // This is the "pad of paper" where your plaintext, keystream & ciphertext results are calculated and recorded.
            Console.WriteLine("Welcome to the Pontifex Solitaire Encryption Program.");
            Console.WriteLine("This program uses a deck of 54 Solitaire playing cards (including both Jokers)");
            Console.WriteLine("to generate a set of keystream numbers for use in encrypting a message that's");
            Console.WriteLine("provided by the user.  This program will also create & use a duplicate deck to");
            Console.WriteLine("decipher the encrypted message back into plaintext.");
            Console.WriteLine();
            Console.Write("The first Deck has been created; would you like to see the first Deck? (y/n): ");
            string seeDeck = Console.ReadLine();
            if (seeDeck == "y") {
                encryptDeck.checkDeck();
            }
            Console.WriteLine();
            encryptDeck.randomizeDeck();

            // This is the second Deck that's used to decipher the encrypted message generated by the "encryptDeck" deck.  It is an exact duplicate of the
            // first Deck that was used to encrypt the plaintext message.
            Deck decryptDeck = new Deck();
            decryptDeck.duplicateDeck(encryptDeck);
            Console.Write("The second duplicate Deck has been created to decipher the encrypted message; would you like to see the second Deck? (y/n): ");
            seeDeck = Console.ReadLine();
            if (seeDeck == "y") {
                decryptDeck.checkDeck();
            }
            Console.WriteLine();

            // Now we ask the user for a message to encrypt.
            int messageLength = notePad.getPlaintextMessage();
            for (int i = 0; i < messageLength; i++) {
				encryptDeck.step1SJMove();
				encryptDeck.step2LJMove();
				encryptDeck.step3TripleCut();
				encryptDeck.step4CountCut();
				int outputCardValue = encryptDeck.step5OutputCard(); // This variable will contain the output card's value.

                // If Step 5 generates either the Small or Large Joker (whose values are 53 and 0, respectively), then the result is
                // to be ignored and we're to start over from Step 1.  Note that we leave the deck in the order it was in at the end
                // of Step 5 when it produces a Joker; we're not to shuffle or re-order the deck at all.
				while (outputCardValue == 0 || outputCardValue == 53) {
					encryptDeck.step1SJMove();
					encryptDeck.step2LJMove();
					encryptDeck.step3TripleCut();
					encryptDeck.step4CountCut();
					outputCardValue = encryptDeck.step5OutputCard();
				}
                outputCardValue = encryptDeck.step6ConvertToNumber(outputCardValue);
				notePad.keystreamRecord(i, outputCardValue);
			}
            notePad.genCiphertextNumber();
            notePad.ciphertextRecord();

            // Here we'll display the results of the encryption algorithm.
			notePad.plaintextDisplay();
			notePad.keystreamDisplay();
            notePad.ciphertextNumDisplay();
            notePad.ciphertextLetterDisplay();
            Console.WriteLine();

            // Now to offer to decipher the encrypted message using the decryptDeck instance.
            Console.Write("Would you like to use the second Deck to decipher this encrypted message? (y/n): ");
            string decipherDeck = Console.ReadLine();
            if (decipherDeck == "y") {
                // First, give the second Deck the ciphertext message as if it was the input given by the .getMessage() method.
                // This will also set the lengths of the various arrays within decryptDeck's Deck instance, which can be used
                // to generate the keystream numbers and the deciphered plaintext message.
                messageLength = notePad.getCiphertextMessage();
                for (int i = 0; i < messageLength; i++) {
                    decryptDeck.step1SJMove();
                    decryptDeck.step2LJMove();
                    decryptDeck.step3TripleCut();
                    decryptDeck.step4CountCut();
                    int outputCardValue = decryptDeck.step5OutputCard(); // This variable will contain the output card's value.

                    // If Step 5 generates either the Small or Large Joker (whose values are 53 and 0, respectively), then the result is
                    // to be ignored and we're to start over from Step 1.  Note that we leave the deck in the order it was in at the end
                    // of Step 5 when it produces a Joker; we're not to shuffle or re-order the deck at all.
                    while (outputCardValue == 0 || outputCardValue == 53) {
                        decryptDeck.step1SJMove();
                        decryptDeck.step2LJMove();
                        decryptDeck.step3TripleCut();
                        decryptDeck.step4CountCut();
                        outputCardValue = decryptDeck.step5OutputCard();
                    }
                    outputCardValue = decryptDeck.step6ConvertToNumber(outputCardValue);
                    notePad.keystreamRecord(i, outputCardValue);
                }
                notePad.genDecipheredMessageNumber();
                notePad.decipheredMessageRecord();

                // Here we'll display the results of the deciphering algorithm.
                notePad.ciphertextLetterDisplay();
                notePad.ciphertextNumDisplay();
                notePad.keystreamDisplay();
                notePad.decipheredMessageNumberDisplay();
                notePad.decipheredMessageLetterDisplay();
            }
        }
    }

}
